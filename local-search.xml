<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL 从表中分批读取数据技巧</title>
    <link href="/2023/12/28/mysql-loading-data-from-table-in-batches-tips/"/>
    <url>/2023/12/28/mysql-loading-data-from-table-in-batches-tips/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有时候我们的程序需要读取大量的表数据，最简单的方法就是直接全部读出：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> category <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>表数据量不大的时候，这样问题不大。</p><p>但当表数据的时候大的时候，会导致 MySQL 短时间压力过大，而且将如此多的数据读到内存中，程序占用的内存也会比较大。</p><p>利索当然的，我们会想要分批处理数据。</p><h1 id="通过分页（order-offset-limit）分批次读取"><a href="#通过分页（order-offset-limit）分批次读取" class="headerlink" title="通过分页（order, offset, limit）分批次读取"></a>通过分页（order, offset, limit）分批次读取</h1><p>假设我们每次读取 1000 条数据，可以这样读取：</p><p>第一次读取：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> category <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">0</span>, <span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><p>第二次读取：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> category <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">1000</span>, <span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><p>以此类推，直到读取不到数据后，即可完成读取。</p><p>这样的方案也很简单，但是存在一个问题就是：<code>offset</code> 越大查询的速度越慢。</p><p>这是 MySQL 在执行 <code>limit</code> 子句的时候，会执行整个查询，然后再跳过指定的数量的行数，再返回结果。跳过的行数越大，查询越慢。</p><p>用黑色表示 MySQL 会读取的数据，通过分页分批次查询可以这样表示：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">第一次查询<br>|<span class="hljs-string">█░░░░░░░░░</span>|<br><br>第二次查询<br>|<span class="hljs-string">██░░░░░░░░</span>|<br><br>最后一次查询<br>|<span class="hljs-string">██████████</span>|<br></code></pre></td></tr></table></figure><p>可以看到，实际上越深的分页，会将之前读取的数据再读取一遍。这是导致越到后面，查询越慢的原因，越到后面查询的消耗就越大。</p><p>一个对比的例子：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">mysql&gt; <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> bind_status &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id <span class="hljs-keyword">limit</span> <span class="hljs-number">10</span>, <span class="hljs-number">10</span>;<br>...<br>10 rows <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br><br>mysql&gt; <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> bind_status &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id <span class="hljs-keyword">limit</span> <span class="hljs-number">2007967</span>, <span class="hljs-number">10</span>;<br>...<br>10 rows <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.90</span> sec)<br></code></pre></td></tr></table></figure><h1 id="基于索引分批次读取"><a href="#基于索引分批次读取" class="headerlink" title="基于索引分批次读取"></a>基于索引分批次读取</h1><p>我们想要避免上面的情况，尽量让每次查询都能够只扫描一部分数据，减少消耗。</p><p>这时候，我们可以利用索引，跳过已经扫描过的数据。</p><p>假设每次读取 1000 行，那么现在的读取语句就变成了这样：</p><p>第一次读取：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> category <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><p>假设第一次读取返回的最大 id 为 1500，那么第二次读取的语句则是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">1500</span> category <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><p>以此类推，直到读取不到数据后，即可完成读取。</p><p>用黑色表示 MySQL 会读取的数据，通过索引分批次查询可以这样表示：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">第一次查询<br>|<span class="hljs-string">█░░░░░░░░░</span>|<br><br>第二次查询<br>|<span class="hljs-string">░█░░░░░░░░</span>|<br><br>最后一次查询<br>|<span class="hljs-string">░░░░░░░░░█</span>|<br></code></pre></td></tr></table></figure><p>通过索引，我们跳过已经扫描的部分，从上次扫描的末尾开始扫描。</p>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过 straight_join 指定 MySQL 连表查询的执行顺序改善查询性能</title>
    <link href="/2023/12/27/specifying-join-order-in-mysql-query/"/>
    <url>/2023/12/27/specifying-join-order-in-mysql-query/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当执行连表查询的时候，优化器会选择他认为最优的执行顺序，这可能导致一些问题。</p><p>假设存在三个表，分别有不同的行数：</p><table><thead><tr><th align="center">表名</th><th align="center">行数</th></tr></thead><tbody><tr><td align="center"><code>tbl_a</code></td><td align="center">60000（6W）</td></tr><tr><td align="center"><code>tbl_b</code></td><td align="center">200000（20W）</td></tr><tr><td align="center"><code>tbl_c</code></td><td align="center">5000000（500W）</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br>    <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">from</span> tbl_a a<br><span class="hljs-keyword">join</span> tbl_b b <span class="hljs-keyword">on</span> a.user_id <span class="hljs-operator">=</span> b.user_id<br><span class="hljs-keyword">join</span> tbl_c c <span class="hljs-keyword">on</span> a.user_id <span class="hljs-operator">=</span> c.user_id<br><span class="hljs-keyword">where</span><br>    a.package_id <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br>    <span class="hljs-keyword">and</span> c.create_time <span class="hljs-keyword">between</span> <span class="hljs-number">1604419200</span> <span class="hljs-keyword">and</span> <span class="hljs-number">1703692800</span><br></code></pre></td></tr></table></figure><p>比较符合直觉的情况就是 <code>MySQL</code> 使用 <code>tbl_a</code> 作为驱动表，与 <code>tbl_b</code> 连接后，再与 <code>tbl_c</code> 连接。</p><p>但是实际情况可能不是这个顺序，比如优化器发现 <code>tbl_c.create_time</code> 是存在索引的，判断后按照如下顺序链接：</p><ul><li><code>tbl_c</code></li><li><code>tbl_a</code></li><li><code>tbl_b</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------------+--------+--------------------------------------------------------------------+------------------------------------+---------+----------------------------------+---------+----------+--------------------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span> <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type   <span class="hljs-operator">|</span> possible_keys                                                      <span class="hljs-operator">|</span> key                                <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>                              <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span>    <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra                    <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------------+--------+--------------------------------------------------------------------+------------------------------------+---------+----------------------------------+---------+----------+--------------------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> c     <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">range</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">PRIMARY</span>,user_id_idx,create_time_index <span class="hljs-operator">|</span> create_time_index <span class="hljs-operator">|</span> <span class="hljs-number">8</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>                             <span class="hljs-operator">|</span> <span class="hljs-number">2075427</span> <span class="hljs-operator">|</span>   <span class="hljs-number">100.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span>; <span class="hljs-keyword">Using</span> index <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> a     <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> eq_ref <span class="hljs-operator">|</span> uni_owner_user_id,user_id                                                <span class="hljs-operator">|</span> uni_owner_user_id                     <span class="hljs-operator">|</span> <span class="hljs-number">1026</span>    <span class="hljs-operator">|</span> const,user_id <span class="hljs-operator">|</span>       <span class="hljs-number">1</span> <span class="hljs-operator">|</span>   <span class="hljs-number">100.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span>; <span class="hljs-keyword">Using</span> index <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> SIMPLE      <span class="hljs-operator">|</span> b     <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> eq_ref <span class="hljs-operator">|</span> user_id                                                               <span class="hljs-operator">|</span> user_id                               <span class="hljs-operator">|</span> <span class="hljs-number">1023</span>    <span class="hljs-operator">|</span> user_id       <span class="hljs-operator">|</span>       <span class="hljs-number">1</span> <span class="hljs-operator">|</span>   <span class="hljs-number">100.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span>; <span class="hljs-keyword">Using</span> index <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+-------------+-------+------------+--------+--------------------------------------------------------------------+------------------------------------+---------+----------------------------------+---------+----------+--------------------------+****</span><br></code></pre></td></tr></table></figure><p>虽然使用了 <code>tbl_c.create_time</code> 索引，但是导致了大表驱动小表，查询速度反而不如预期：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">+----------+</span><br><span class="hljs-section">| count(*) |</span><br><span class="hljs-section">+----------+</span><br><span class="hljs-section">|        7 |</span><br><span class="hljs-section">+----------+</span><br>1 row in set (11.54 sec)<br></code></pre></td></tr></table></figure><p>通常来说，优化器的选择是最好的，但是遇到这种情况，我们就需要指定连接的顺序了。</p><h1 id="使用-straight-join-指定顺序"><a href="#使用-straight-join-指定顺序" class="headerlink" title="使用 straight_join 指定顺序"></a>使用 straight_join 指定顺序</h1><p>为了达到指定连接顺序的目的，我们可以使用 <code>straight_join</code> 。</p><p>在 MySQL 文档中这样描述 <code>straight_join</code>：</p><blockquote><p><strong>STRAIGHT_JOIN</strong> is similar to JOIN, except that the left table is always read before the right table. This can be used for those (few) cases for which the join optimizer processes the tables in a suboptimal order.</p></blockquote><p>翻译过来就是：</p><p><strong>STRAIGHT_JOIN</strong> 与 JOIN 类似，除了左边的表总是在读取右边的表前读取。<code>straight_join</code> 用于 join 优化器未使用最优顺序来处理多个表的情况。</p><p>使用 <code>straight_join</code> 来修改上面的查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span><br>    <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<br><span class="hljs-keyword">from</span> tbl_a a<br>straight_join tbl_b b <span class="hljs-keyword">on</span> a.user_id <span class="hljs-operator">=</span> b.user_id<br>straight_join tbl_c c <span class="hljs-keyword">on</span> a.user_id <span class="hljs-operator">=</span> c.user_id<br><span class="hljs-keyword">where</span><br>    a.package_id <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br>    <span class="hljs-keyword">and</span> c.create_time <span class="hljs-keyword">between</span> <span class="hljs-number">1604419200</span> <span class="hljs-keyword">and</span> <span class="hljs-number">1703692800</span><br></code></pre></td></tr></table></figure><p>再执行一次，发现效果好多了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">+</span><span class="hljs-comment">----------+</span><br><span class="hljs-operator">|</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------+</span><br><span class="hljs-operator">|</span>        <span class="hljs-number">7</span> <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----------+</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">1.57</span> sec)<br></code></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>通常不需要使用 straight_join 来指定顺序，除非你知道自己在干什么</li><li>随着时间推移，你的表数据分布可能发生改变，你可能需要重新判断使用 straight_join 的查询是否还是最优的</li></ul><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://dev.mysql.com/doc/refman/8.0/en/join.html">MySQL 8.0 Reference Manual - JOIN Clause</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>尝试在工程中使用 Go 泛型</title>
    <link href="/2023/08/14/try-to-use-go-generics-in-the-project/"/>
    <url>/2023/08/14/try-to-use-go-generics-in-the-project/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Go 从 1.18 版本开始支持泛型。一起看看怎么回事。</p><h1 id="从-max、min、sum-开始"><a href="#从-max、min、sum-开始" class="headerlink" title="从 max、min、sum 开始"></a>从 max、min、sum 开始</h1><p>找出一个 slice 的最大值、最小值和对一个 slice 求和是很常见的操作，通常我们需要对每种类型的 slice 的都单独实现一套函数操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MaxOfInts</span><span class="hljs-params">(values []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123; ... &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MaxOfFloats</span><span class="hljs-params">(values []<span class="hljs-keyword">float32</span>)</span> <span class="hljs-title">float32</span></span> &#123; ... &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MinOfInts</span><span class="hljs-params">(values []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123; ... &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MinOfFloats</span><span class="hljs-params">(values []<span class="hljs-keyword">float32</span>)</span> <span class="hljs-title">float32</span></span> &#123; ... &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SumInts</span><span class="hljs-params">(values []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123; ... &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SumFloats</span><span class="hljs-params">(values []<span class="hljs-keyword">float32</span>)</span> <span class="hljs-title">float32</span></span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>甚至里面的代码都是一样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SumInts</span><span class="hljs-params">(values []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">var</span> s = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>        s += v<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SumFloats</span><span class="hljs-params">(values []<span class="hljs-keyword">float32</span>)</span> <span class="hljs-title">float32</span></span> &#123;<br>    <span class="hljs-keyword">var</span> s = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>        s += v<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><p>本着 DRY（Don’t Repeat Yourself） 原则，有些人试图使用其他方法来解决这个问题，比如使用反射、代码生成器。反射复杂且性能一般，代码生成器又需要引入新的依赖。</p><p>在 Go 推出泛型后带来了新的方案，通过泛型，我们的求和函数支持处理 <code>[]int</code> 和 <code>[]float</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sum</span>[<span class="hljs-title">T</span> <span class="hljs-title">int</span> | <span class="hljs-title">float32</span>]<span class="hljs-params">(values []T)</span> <span class="hljs-title">T</span></span> &#123;<br>    <span class="hljs-keyword">var</span> s T<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>        s += v<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;sum ints: %d\n&quot;</span>, Sum([]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;)) <span class="hljs-comment">// sum ints: 15</span><br>    fmt.Printf(<span class="hljs-string">&quot;sum floats: %.2f\n&quot;</span>, Sum([]<span class="hljs-keyword">float32</span>&#123;<span class="hljs-number">1.1</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">3.3</span>, <span class="hljs-number">4.4</span>, <span class="hljs-number">5.5</span>&#125;)) <span class="hljs-comment">// sum floats: 16.50</span><br>&#125;<br></code></pre></td></tr></table></figure><p>仔细看泛型函数 Sum 的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sum</span>[<span class="hljs-title">T</span> <span class="hljs-title">int</span> | <span class="hljs-title">float32</span>]<span class="hljs-params">(values []T)</span> <span class="hljs-title">T</span></span><br></code></pre></td></tr></table></figure><p>与一般的函数相比，在函数名的后面多了用方括号的这一段，称为类型参数（type parameters）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">[T <span class="hljs-keyword">int</span> | <span class="hljs-keyword">float32</span>]<br></code></pre></td></tr></table></figure><p>其中 <code>T</code> 为类型参数名称、<code>int | float32</code> 为类型参数约束，代表 <code>T</code> 允许是 <code>int</code> 或者 <code>float32</code>。</p><p>根据上面的例子，泛型版本 <code>Min</code>、<code>Max</code> 也手到擒来：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Min</span>[<span class="hljs-title">T</span> <span class="hljs-title">int</span> | <span class="hljs-title">float32</span>]<span class="hljs-params">(v T, values ...T)</span> <span class="hljs-title">T</span></span> &#123;<br>min := v<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> values &#123;<br><span class="hljs-keyword">if</span> values[i] &lt; min &#123;<br>min = values[i]<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> min<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Max</span>[<span class="hljs-title">T</span> <span class="hljs-title">int</span> | <span class="hljs-title">float32</span>]<span class="hljs-params">(v T, values ...T)</span> <span class="hljs-title">T</span></span> &#123;<br>max := v<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> values &#123;<br><span class="hljs-keyword">if</span> values[i] &gt; max &#123;<br>max = values[i]<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> max<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="类型参数约束"><a href="#类型参数约束" class="headerlink" title="类型参数约束"></a>类型参数约束</h1><p>类型约束定义了允许作为类型参数的一组类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Min</span>[<span class="hljs-title">T</span> <span class="hljs-title">int</span> | <span class="hljs-title">float32</span>]<span class="hljs-params">(v T, values ...T)</span> <span class="hljs-title">T</span></span><br></code></pre></td></tr></table></figure><p>比如这里 T 的约束，就是 <code>int | float32</code>，允许使用 <code>int</code> 或者 <code>float32</code> 作为类型参数。</p><p>假设我们需要让 <code>Min</code>、<code>Max</code>、<code>Sum</code> 这几个泛型函数传入支持 <code>string</code> 类型，我们可以这样做：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Min</span>[<span class="hljs-title">T</span> <span class="hljs-title">int</span> | <span class="hljs-title">float32</span> | <span class="hljs-title">string</span>]<span class="hljs-params">(v T, values ...T)</span> <span class="hljs-title">T</span></span> &#123; ... &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Max</span>[<span class="hljs-title">T</span> <span class="hljs-title">int</span> | <span class="hljs-title">float32</span> | <span class="hljs-title">string</span>]<span class="hljs-params">(v T, values ...T)</span> <span class="hljs-title">T</span></span> &#123; ... &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sum</span>[<span class="hljs-title">T</span> <span class="hljs-title">int</span> | <span class="hljs-title">float32</span> | <span class="hljs-title">string</span>]<span class="hljs-params">(values []T)</span> <span class="hljs-title">T</span></span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><h2 id="使用-interface-定义一组类型"><a href="#使用-interface-定义一组类型" class="headerlink" title="使用 interface 定义一组类型"></a>使用 interface 定义一组类型</h2><p>我们修改了三个地方，使得这三个函数支持传入 <code>string</code> 类型，有没有更好的方法呢，答案是有的。</p><p>在过去 <code>interface</code> 用于定义一组方法，现在 <code>interface</code> 可以用于定义一组类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyTypeSet <span class="hljs-keyword">interface</span> &#123;<br>    <span class="hljs-keyword">int</span> | <span class="hljs-keyword">float32</span> | <span class="hljs-keyword">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以将它用于类型约束：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Min</span>[<span class="hljs-title">T</span> <span class="hljs-title">MyTypeSet</span>]<span class="hljs-params">(v T, values ...T)</span> <span class="hljs-title">T</span></span> &#123; ... &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Max</span>[<span class="hljs-title">T</span> <span class="hljs-title">MyTypeSet</span>]<span class="hljs-params">(v T, values ...T)</span> <span class="hljs-title">T</span></span> &#123; ... &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sum</span>[<span class="hljs-title">T</span> <span class="hljs-title">MyTypeSet</span>]<span class="hljs-params">(values []T)</span> <span class="hljs-title">T</span></span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>如果后续我们还需要支持其他类型，就可以直接修改 <code>MyTypeSet</code> 即可。</p><p>另外 <code>[T int | float32 | string]</code> 其实是 <code>[T interface &#123; int | float32 | string &#125;]</code> 的语法糖，允许忽略 <code>interface&#123;&#125;</code> 使得结构紧凑。</p><h2 id="支持类型别名"><a href="#支持类型别名" class="headerlink" title="支持类型别名"></a>支持类型别名</h2><p>我们定义一个 <code>MyInt</code> 作为 <code>int</code> 的别名，尝试在 <code>Sum</code> 中使用它：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-keyword">int</span><br><br>...<br><br><span class="hljs-keyword">var</span> data []MyInt = ...<br><span class="hljs-keyword">var</span> sumOfData = Sum(data)<br></code></pre></td></tr></table></figure><p>编译会提示如下错误：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">MyInt</span> does not implement MyTypeSet (possibly missing <span class="hljs-regexp">~ for</span> int in constraint MyTypeSet)<br></code></pre></td></tr></table></figure><p>这里提示我们可能在 <code>MyTypeSet</code> 约束中的 <code>int</code> 缺少 <code>~</code> 符号。修改约束，添加上 <code>~</code> 符号：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyTypeSet <span class="hljs-keyword">interface</span> &#123;<br>    ~<span class="hljs-keyword">int</span> | <span class="hljs-keyword">float32</span> | <span class="hljs-keyword">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>再次编译，没有问题。那么 <code>~</code> 符号的作用是什么呢？我们看看官方文档的定义：</p><blockquote><p>~T notation stands for “all types that have the underlying type T”</p></blockquote><p>~T 符号表示“具有底层类型 T 的所有类型”。</p><p>那么 <code>~int</code> 就表示底层类型为 <code>int</code> 的所有类型，自然就可以处理 <code>MyInt</code>。</p><h2 id="常用的内建的类型约束"><a href="#常用的内建的类型约束" class="headerlink" title="常用的内建的类型约束"></a>常用的内建的类型约束</h2><ul><li>any：interface{} 的别名，等于没有约束</li><li>comparable：类型支持 <code>==</code> 和 <code>!=</code> 操作</li></ul><p>另外 <code>golang.org/x/exp</code> 定义了一组有用的类型约束，点击这里查看：<a href="https://pkg.go.dev/golang.org/x/exp/constraints">constraints</a></p><h1 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h1><h2 id="简单实现一个泛型-Set"><a href="#简单实现一个泛型-Set" class="headerlink" title="简单实现一个泛型 Set"></a>简单实现一个泛型 Set</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Set[T comparable] <span class="hljs-keyword">struct</span> &#123;<br>inner <span class="hljs-keyword">map</span>[T]<span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewSet</span>[<span class="hljs-title">T</span> <span class="hljs-title">comparable</span>]<span class="hljs-params">(values ...T)</span> *<span class="hljs-title">Set</span>[<span class="hljs-title">T</span>]</span> &#123;<br>s := &amp;Set[T]&#123;<br>inner: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[T]<span class="hljs-keyword">struct</span>&#123;&#125;),<br>&#125;<br><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>s.Add(v)<br>&#125;<br><br><span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Set[T])</span> <span class="hljs-title">Add</span><span class="hljs-params">(v T)</span></span> &#123;<br>s.inner[v] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Set[T])</span> <span class="hljs-title">Remove</span><span class="hljs-params">(v T)</span></span> &#123;<br><span class="hljs-built_in">delete</span>(s.inner, v)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Set[T])</span> <span class="hljs-title">Contains</span><span class="hljs-params">(v T)</span> <span class="hljs-title">bool</span></span> &#123;<br>_, ok := s.inner[v]<br><span class="hljs-keyword">return</span> ok<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Set[T])</span> <span class="hljs-title">Len</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(s.inner)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Set[T])</span> <span class="hljs-title">Values</span><span class="hljs-params">()</span> []<span class="hljs-title">T</span></span> &#123;<br>values := <span class="hljs-built_in">make</span>([]T, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(s.inner))<br><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> s.inner &#123;<br>values = <span class="hljs-built_in">append</span>(values, v)<br>&#125;<br><br><span class="hljs-keyword">return</span> values<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用-gorm-查询的常用操作"><a href="#使用-gorm-查询的常用操作" class="headerlink" title="使用 gorm 查询的常用操作"></a>使用 gorm 查询的常用操作</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">QueryObjectsByCondsWithDb</span>[<span class="hljs-title">T</span> <span class="hljs-title">any</span>]<span class="hljs-params">(db *gorm.DB, conds ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">([]T, error)</span></span> &#123;<br><span class="hljs-keyword">var</span> objects []T<br>err := db.Find(&amp;objects, conds...).Error<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">return</span> objects, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">QueryObjectMapByCondsWithDb</span>[<span class="hljs-title">K</span> <span class="hljs-title">comparable</span>, <span class="hljs-title">V</span> <span class="hljs-title">any</span>]<span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">db *gorm.DB,</span></span><br><span class="hljs-params"><span class="hljs-function">keyOf <span class="hljs-keyword">func</span>(v *V)</span> <span class="hljs-title">K</span>,</span><br>conds ...<span class="hljs-keyword">interface</span>&#123;&#125;,<br>) (<span class="hljs-keyword">map</span>[K]*V, error) &#123;<br><span class="hljs-keyword">var</span> objects []V<br>err := db.Find(&amp;objects, conds...).Error<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br>objectMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[K]*V)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> objects &#123;<br>v := &amp;objects[i]<br>objectMap[keyOf(v)] = v<br>&#125;<br><br><span class="hljs-keyword">return</span> objectMap, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="尝试实现类似-Rust-风格的迭代器"><a href="#尝试实现类似-Rust-风格的迭代器" class="headerlink" title="尝试实现类似 Rust 风格的迭代器"></a>尝试实现类似 Rust 风格的迭代器</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> FilterFn[T any] <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(v T)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-keyword">type</span> MapFn[T any] <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(v T)</span> <span class="hljs-title">T</span></span><br><br><span class="hljs-keyword">type</span> Filter[T any] <span class="hljs-keyword">struct</span> &#123;<br>Apply FilterFn[T]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f Filter[T])</span> <span class="hljs-title">Next</span><span class="hljs-params">(v T)</span> <span class="hljs-params">(T, <span class="hljs-keyword">bool</span>)</span></span> &#123;<br><span class="hljs-keyword">return</span> v, f.Apply(v)<br>&#125;<br><br><span class="hljs-keyword">type</span> Map[T any] <span class="hljs-keyword">struct</span> &#123;<br>Apply MapFn[T]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m Map[T])</span> <span class="hljs-title">Next</span><span class="hljs-params">(v T)</span> <span class="hljs-params">(T, <span class="hljs-keyword">bool</span>)</span></span> &#123;<br><span class="hljs-keyword">return</span> m.Apply(v), <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Take[T any] <span class="hljs-keyword">struct</span> &#123;<br>n     <span class="hljs-keyword">int</span><br>taken <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Take[T])</span> <span class="hljs-title">Next</span><span class="hljs-params">(v T)</span> <span class="hljs-params">(T, <span class="hljs-keyword">bool</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> t.taken &gt;= t.n &#123;<br><span class="hljs-keyword">return</span> v, <span class="hljs-literal">false</span><br>&#125;<br><br>t.taken += <span class="hljs-number">1</span><br><span class="hljs-keyword">return</span> v, <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Skip[T any] <span class="hljs-keyword">struct</span> &#123;<br>n       <span class="hljs-keyword">int</span><br>skipped <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Skip[T])</span> <span class="hljs-title">Next</span><span class="hljs-params">(v T)</span> <span class="hljs-params">(T, <span class="hljs-keyword">bool</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> t.skipped &lt; t.n &#123;<br>t.skipped += <span class="hljs-number">1</span><br><span class="hljs-keyword">return</span> v, <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-keyword">return</span> v, <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-keyword">type</span> IteratorNext[T any] <span class="hljs-keyword">interface</span> &#123;<br>Next(v T) (T, <span class="hljs-keyword">bool</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> Iterator[T any] <span class="hljs-keyword">struct</span> &#123;<br>inner      []T<br>operations []IteratorNext[T]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(iter *Iterator[T])</span> <span class="hljs-title">Filter</span><span class="hljs-params">(fn FilterFn[T])</span> *<span class="hljs-title">Iterator</span>[<span class="hljs-title">T</span>]</span> &#123;<br>iter.operations = <span class="hljs-built_in">append</span>(iter.operations, &amp;Filter[T]&#123;<br>Apply: fn,<br>&#125;)<br><br><span class="hljs-keyword">return</span> iter<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(iter *Iterator[T])</span> <span class="hljs-title">Map</span><span class="hljs-params">(fn MapFn[T])</span> *<span class="hljs-title">Iterator</span>[<span class="hljs-title">T</span>]</span> &#123;<br>iter.operations = <span class="hljs-built_in">append</span>(iter.operations, &amp;Map[T]&#123;<br>Apply: fn,<br>&#125;)<br><br><span class="hljs-keyword">return</span> iter<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(iter *Iterator[T])</span> <span class="hljs-title">Take</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">Iterator</span>[<span class="hljs-title">T</span>]</span> &#123;<br>iter.operations = <span class="hljs-built_in">append</span>(iter.operations, &amp;Take[T]&#123;<br>n: n,<br>&#125;)<br><br><span class="hljs-keyword">return</span> iter<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(iter *Iterator[T])</span> <span class="hljs-title">Skip</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">Iterator</span>[<span class="hljs-title">T</span>]</span> &#123;<br>iter.operations = <span class="hljs-built_in">append</span>(iter.operations, &amp;Skip[T]&#123;<br>n: n,<br>&#125;)<br><br><span class="hljs-keyword">return</span> iter<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(iter *Iterator[T])</span> <span class="hljs-title">applyOperations</span><span class="hljs-params">(v T)</span> <span class="hljs-params">(T, <span class="hljs-keyword">bool</span>)</span></span> &#123;<br><span class="hljs-keyword">var</span> (<br>tmp  = v<br>keep = <span class="hljs-literal">false</span><br>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> iter.operations &#123;<br>tmp, keep = iter.operations[i].Next(tmp)<br><span class="hljs-keyword">if</span> !keep &#123;<br><span class="hljs-keyword">return</span> tmp, keep<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> tmp, keep<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(iter *Iterator[T])</span> <span class="hljs-title">Collect</span><span class="hljs-params">()</span> []<span class="hljs-title">T</span></span> &#123;<br><span class="hljs-keyword">var</span> result []T<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> iter.inner &#123;<br>v, keep := iter.applyOperations(iter.inner[i])<br><span class="hljs-keyword">if</span> !keep &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>result = <span class="hljs-built_in">append</span>(result, v)<br>&#125;<br><br><span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(iter *Iterator[T])</span> <span class="hljs-title">Count</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(iter.Collect())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IntoInterator</span>[<span class="hljs-title">T</span> <span class="hljs-title">any</span>]<span class="hljs-params">(ss []T)</span> *<span class="hljs-title">Iterator</span>[<span class="hljs-title">T</span>]</span> &#123;<br><span class="hljs-keyword">return</span> &amp;Iterator[T]&#123;<br>inner: ss,<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> data []<span class="hljs-keyword">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>data = <span class="hljs-built_in">append</span>(data, i)<br>&#125;<br>data = IntoInterator(data).<br>Filter(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(v <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123; <span class="hljs-keyword">return</span> v%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#125;).<br>Map(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(v <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * v &#125;).<br>Skip(<span class="hljs-number">5</span>).<br>Take(<span class="hljs-number">5</span>).<br>Collect()<br><br>fmt.Printf(<span class="hljs-string">&quot;data: %#v\n&quot;</span>, data) <span class="hljs-comment">// data: []int&#123;20, 24, 28, 32, 36&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="对性能的影响"><a href="#对性能的影响" class="headerlink" title="对性能的影响"></a>对性能的影响</h1><p>我们定义一个 IntSum 和一个 GenericSum：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyTypeSet <span class="hljs-keyword">interface</span> &#123;<br>~<span class="hljs-keyword">int</span> | ~<span class="hljs-keyword">float32</span> | ~<span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GenericSum</span>[<span class="hljs-title">T</span> <span class="hljs-title">MyTypeSet</span>]<span class="hljs-params">(values []T)</span> <span class="hljs-title">T</span></span> &#123;<br><span class="hljs-keyword">var</span> s T<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>s += v<br>&#125;<br><span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IntSum</span><span class="hljs-params">(values []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">var</span> s <span class="hljs-keyword">int</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>s += v<br>&#125;<br><span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><p>增加性能测试的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkGenericSum</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">var</span> data []<span class="hljs-keyword">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>data = <span class="hljs-built_in">append</span>(data, i)<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>_ = GenericSum(data)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkIntSum</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">var</span> data []<span class="hljs-keyword">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>data = <span class="hljs-built_in">append</span>(data, i)<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>_ = IntSum(data)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行测试，获取测试结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">goos</span>: darwin<br><span class="hljs-attribute">goarch</span>: amd<span class="hljs-number">64</span><br><span class="hljs-attribute">cpu</span>: Intel(R) Core(TM) i<span class="hljs-number">5</span>-<span class="hljs-number">7267</span>U CPU @ <span class="hljs-number">3</span>.<span class="hljs-number">10</span>GHz<br><span class="hljs-attribute">BenchmarkGenericSum</span>-<span class="hljs-number">4</span>   <span class="hljs-number">24427492</span>        <span class="hljs-number">50</span>.<span class="hljs-number">50</span> ns/op       <span class="hljs-number">0</span> B/op       <span class="hljs-number">0</span> allocs/op<br><span class="hljs-attribute">BenchmarkIntSum</span>-<span class="hljs-number">4</span>   <span class="hljs-number">31268010</span>        <span class="hljs-number">38</span>.<span class="hljs-number">90</span> ns/op       <span class="hljs-number">0</span> B/op       <span class="hljs-number">0</span> allocs/op<br></code></pre></td></tr></table></figure><p>可以看到泛型版本比普通版本慢了差不多 25%，这是为什么？</p><p>这和 Go 的泛型实现有关，具体可以参考这篇文章<a href="https://www.bmpi.dev/dev/deep-in-program-language/how-to-implement-generics">编程语言是如何实现泛型的</a>。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://go.dev/doc/tutorial/generics">Tutorial: Getting started with generics</a></li><li><a href="https://go.dev/blog/comparable">All your comparable types</a></li><li><a href="https://www.bmpi.dev/dev/deep-in-program-language/how-to-implement-generics">编程语言是如何实现泛型的</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Generics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 中变量的类型和可变性</title>
    <link href="/2022/06/14/type-and-mutability-of-variable-in-rust/"/>
    <url>/2022/06/14/type-and-mutability-of-variable-in-rust/</url>
    
    <content type="html"><![CDATA[<p>初学 Rust 的时候，容易将可变引用类型和自身可变性弄混，下面以几个例子来说明其中的区别。</p><p>下面代码中的 <code>r1</code>、<code>r2</code> 和 <code>r3</code> 有啥区别？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> string1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);<br><br><span class="hljs-keyword">let</span> r1 = &amp;<span class="hljs-keyword">mut</span> string1;<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> r2 = &amp;string1;<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> r3 = &amp;<span class="hljs-keyword">mut</span> string1;<br></code></pre></td></tr></table></figure><p>咋一看好像都差不多，实际上有类型和自身可变性的区别。</p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>这里增加一个获取类型的函数，并降每个类型打印出来:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">type_of</span></span>&lt;T&gt;(_: &amp;T) -&gt; &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-built_in">str</span> &#123;<br>    std::any::type_name::&lt;T&gt;()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> string1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> r1 = &amp;<span class="hljs-keyword">mut</span> string1;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;type of r1: &#123;&#125;&quot;</span>, type_of(&amp;r1));<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> r2 = &amp;string1;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;type of r2: &#123;&#125;&quot;</span>, type_of(&amp;r2));<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> r3 = &amp;<span class="hljs-keyword">mut</span> string1;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;type of r3: &#123;&#125;&quot;</span>, type_of(&amp;r3));<br>&#125;<br></code></pre></td></tr></table></figure><p>运行得到结果：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">of</span></span> r1: &amp;<span class="hljs-keyword">mut</span> alloc::string::<span class="hljs-built_in">String</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">of</span></span> r2: &amp;alloc::string::<span class="hljs-built_in">String</span><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">of</span></span> r3: &amp;<span class="hljs-keyword">mut</span> alloc::string::<span class="hljs-built_in">String</span><br></code></pre></td></tr></table></figure><p>这里可以看到 <code>r1</code> 和 <code>r3</code> 的类型都是 <code>&amp;mut String</code> 而，<code>r2</code> 的类型为 <code>&amp;String</code>。</p><h2 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h2><p>在原本的基础上，我们再添加几行代码，目的是尝试给 <code>r1</code>、<code>r2</code>、<code>r3</code> 赋值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> string2 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">&quot;world&quot;</span>);<br><br>r1 = &amp;<span class="hljs-keyword">mut</span> string2;<br>r2 = &amp;string2;<br>r3 = &amp;<span class="hljs-keyword">mut</span> string2;<br></code></pre></td></tr></table></figure><p>常识编译执行，将会得到下面的错误：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">error[E0384]: cannot assign twice to immutable variable `r1`<br>  --&gt; src/bin/type_and_self_mutability_of_var.rs:17:5<br>   |<span class="hljs-string"></span><br><span class="hljs-string">6  </span>|<span class="hljs-string">     let r1 = &amp;mut string1;</span><br><span class="hljs-string">   </span>|<span class="hljs-string">         --</span><br><span class="hljs-string">   </span>|<span class="hljs-string">         </span>|<br>   |<span class="hljs-string">         first assignment to `r1`</span><br><span class="hljs-string">   </span>|<span class="hljs-string">         help: consider making this binding mutable: `mut r1`</span><br><span class="hljs-string">...</span><br><span class="hljs-string">17 </span>|<span class="hljs-string">     r1 = &amp;mut string2;</span><br><span class="hljs-string">   </span>|<span class="hljs-string">     ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable</span><br></code></pre></td></tr></table></figure><p>根据报错信息，我们得知不能修改不可变变量 <code>r1</code> 的值，虽然 <code>r1</code> 的类型是 <code>&amp;mut String</code>。<br>注释掉 <code>r1 = &amp;mut string2;</code> 后就能正常编译了。三个变量情况汇总成表格：</p><table><thead><tr><th align="center">变量</th><th align="center">类型</th><th align="center">是否可变</th></tr></thead><tbody><tr><td align="center">r1</td><td align="center"><code>&amp;mut String</code></td><td align="center">否</td></tr><tr><td align="center">r2</td><td align="center"><code>&amp;String</code></td><td align="center">是</td></tr><tr><td align="center">r3</td><td align="center"><code>&amp;mut String</code></td><td align="center">是</td></tr></tbody></table><p>可以通过 <code>mut</code> 关键字使得变量自身可变，比如上面代码中的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> r2 = &amp;string1;<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> r3 = &amp;<span class="hljs-keyword">mut</span> string1;<br></code></pre></td></tr></table></figure><p><code>mut</code> 关键字还能在函数声明参数地方和模式匹配的时候使用，比如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(<span class="hljs-keyword">mut</span> bar: <span class="hljs-built_in">String</span>) &#123;<br>    <span class="hljs-comment">// 可以在里面修改 bar</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>和</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(<span class="hljs-keyword">mut</span> proxy_channel) = proxy_channel_rx.recv().<span class="hljs-keyword">await</span> &#123;<br>    <span class="hljs-comment">// 修改 proxy_channel</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li>类型为 <code>&amp;mut T</code> 不代表可以修改自身</li><li>使用 <code>mut</code> 关键字使变量自身可变</li></ul>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go - for range 的陷阱</title>
    <link href="/2021/11/18/pitfall-in-go-for-range/"/>
    <url>/2021/11/18/pitfall-in-go-for-range/</url>
    
    <content type="html"><![CDATA[<p>Go 的 <code>for range</code> 里的<strong>循环变量是共享的</strong>，这可能会引起一些问题，以下面的例子为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Item <span class="hljs-keyword">struct</span> &#123;<br>ID     <span class="hljs-keyword">int64</span><br>Name   <span class="hljs-keyword">string</span><br>Amount <span class="hljs-keyword">int</span><br>&#125;<br><br>items := []Item&#123;<br>    &#123;<br>        ID: <span class="hljs-number">1</span>,<br>        Name: <span class="hljs-string">&quot;mushroom&quot;</span>,<br>        Amount: <span class="hljs-number">2</span>,<br>    &#125;,<br>    &#123;<br>        ID: <span class="hljs-number">2</span>,<br>        Name: <span class="hljs-string">&quot;apple&quot;</span>,<br>        Amount: <span class="hljs-number">5</span>,<br>    &#125;,<br>    &#123;<br>        ID: <span class="hljs-number">3</span>,<br>        Name: <span class="hljs-string">&quot;ore&quot;</span>,<br>        Amount: <span class="hljs-number">1</span>,<br>    &#125;,<br>&#125;<br><br>itemMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int64</span>]*Item)<br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> items &#123;<br>    itemMap[item.ID] = &amp;item<br>&#125;<br><br><span class="hljs-keyword">for</span> id, item := <span class="hljs-keyword">range</span> itemMap &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;id: %d item: %#v\n&quot;</span>, id, *item)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码大致的意思是基于 <code>items</code> 创建一个 <code>id</code> 到 <code>*Item</code> 的映射，执行后结果为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">id</span>: <span class="hljs-number">1</span> item: main.Item&#123;ID:<span class="hljs-number">3</span>, Name:<span class="hljs-string">&quot;ore&quot;</span>, Amount:<span class="hljs-number">1</span>&#125;<br><span class="hljs-attribute">id</span>: <span class="hljs-number">2</span> item: main.Item&#123;ID:<span class="hljs-number">3</span>, Name:<span class="hljs-string">&quot;ore&quot;</span>, Amount:<span class="hljs-number">1</span>&#125;<br><span class="hljs-attribute">id</span>: <span class="hljs-number">3</span> item: main.Item&#123;ID:<span class="hljs-number">3</span>, Name:<span class="hljs-string">&quot;ore&quot;</span>, Amount:<span class="hljs-number">1</span>&#125;<br></code></pre></td></tr></table></figure><p>可以看到结果数据和预期不符，主要的原因就是因为<strong>循环变量是共享的</strong>，我们可以打印循环变量的地址来验证：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> items &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;item)<br>&#125;<br></code></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">0</span>xc<span class="hljs-number">000124000</span><br><span class="hljs-number">0</span>xc<span class="hljs-number">000124000</span><br><span class="hljs-number">0</span>xc<span class="hljs-number">000124000</span><br></code></pre></td></tr></table></figure><p>可以看到 <code>item</code> 的地址一直是 <code>0xc000124000</code>，故可以明白为什么上面的 <code>map</code> 的结果不符合预期。</p><p>要避免这种情况，只需要记住：<strong>用 for range 在遍历的时候，避免取循环变量的地址作为结果，除非你知道自己在干什么</strong></p><p>上面的需求可以通过另一种形式取值来达成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">itemMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int64</span>]*Item)<br><span class="hljs-keyword">for</span> offset := <span class="hljs-keyword">range</span> items &#123;<br>    itemMap[items[offset].ID] = &amp;items[offset]<br>&#125;<br><br><span class="hljs-keyword">for</span> id, item := <span class="hljs-keyword">range</span> itemMap &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;id: %d item: %#v\n&quot;</span>, id, *item)<br>&#125;<br></code></pre></td></tr></table></figure><p>最终结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">id</span>: <span class="hljs-number">1</span> item: main.Item&#123;ID:<span class="hljs-number">1</span>, Name:<span class="hljs-string">&quot;mushroom&quot;</span>, Amount:<span class="hljs-number">2</span>&#125;<br><span class="hljs-attribute">id</span>: <span class="hljs-number">2</span> item: main.Item&#123;ID:<span class="hljs-number">2</span>, Name:<span class="hljs-string">&quot;apple&quot;</span>, Amount:<span class="hljs-number">5</span>&#125;<br><span class="hljs-attribute">id</span>: <span class="hljs-number">3</span> item: main.Item&#123;ID:<span class="hljs-number">3</span>, Name:<span class="hljs-string">&quot;ore&quot;</span>, Amount:<span class="hljs-number">1</span>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于 Hexo 和 Github Pages 服务搭建个人博客实践</title>
    <link href="/2021/07/05/build-personal-blog-base-on-hexo-and-github-pages/"/>
    <url>/2021/07/05/build-personal-blog-base-on-hexo-and-github-pages/</url>
    
    <content type="html"><![CDATA[<h2 id="Hexo-和-Github-Pages-是什么？"><a href="#Hexo-和-Github-Pages-是什么？" class="headerlink" title="Hexo 和 Github Pages 是什么？"></a>Hexo 和 Github Pages 是什么？</h2><p>Hexo 是什么？</p><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote><p>Github Pages 是什么？</p><blockquote><p>GitHub Pages is designed to host your personal, organization, or project pages from a GitHub repository.</p></blockquote><p>Pages 是设计来托管 Github 仓库里面页面的服务。</p><p>而我们要做的事情就是使用 Hexo 生成个人博客的页面，然后再利用 Github Pages 服务来托管。</p><h2 id="使用-Hexo-生成个人博客页面"><a href="#使用-Hexo-生成个人博客页面" class="headerlink" title="使用 Hexo 生成个人博客页面"></a>使用 Hexo 生成个人博客页面</h2><p>通过 npm 安装 ：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>详细的安装教学可以看这里：<a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a></p><p>安装完毕后，初始化博客文件夹：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo init 3vilive-blog<br><span class="hljs-built_in">cd</span> 3vilive-blog<br>npm install<br></code></pre></td></tr></table></figure><p>初始化完毕后，可以看到有这些文件和文件夹：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">➜ ls<br>_config<span class="hljs-selector-class">.landscape</span><span class="hljs-selector-class">.yml</span> node_modules          package<span class="hljs-selector-class">.json</span>          source                yarn<span class="hljs-selector-class">.lock</span><br>_config<span class="hljs-selector-class">.yml</span>           package-lock<span class="hljs-selector-class">.json</span>     scaffolds             themes<br></code></pre></td></tr></table></figure><p>我们主要关注这几项：</p><ul><li><code>_config.yml</code> 是博客的配置</li><li><code>scaffolds</code> 是模板文件夹，新建文章的时候会使用里面的模板</li><li><code>source</code> 资源文件夹</li><li><code>themes</code> 主题文件夹</li></ul><p>接着开始编辑博客配置（<code>_config.yml</code>），首先编辑博客的基本信息 (Site)：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Site</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">3vilive&#x27;s</span> <span class="hljs-string">blog</span><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">&#x27;good luck have fun&#x27;</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">keywords:</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">3vilive</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><br><span class="hljs-attr">timezone:</span> <span class="hljs-string">&#x27;Asia/ShangHai&#x27;</span><br></code></pre></td></tr></table></figure><p>接着设置 URL 这一栏：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># URL</span><br><span class="hljs-comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">https://3vilive.github.io</span><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:day/:title/</span><br><span class="hljs-attr">permalink_defaults:</span><br><span class="hljs-attr">pretty_urls:</span><br>  <span class="hljs-attr">trailing_index:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br>  <span class="hljs-attr">trailing_html:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br></code></pre></td></tr></table></figure><p>我们要使用 Github Pages，直接根据注释说明修改。</p><p>另外就是 <code>pretty_urls.trailing_index</code> 和 <code>pretty_urls.trailing_html</code> 我都设置为 <code>false</code>，因为不想在 URL 上看到 <code>html</code> 后缀。</p><p>为了管理方便，将 <code>new_post_name</code> 修改为为 <code>:year-:month-:day-:title.md </code> 和 <code>post_asset_folder</code> 为 <code>true</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">new_post_name:</span> <span class="hljs-string">:year-:month-:day-:title.md</span><br><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span> <br></code></pre></td></tr></table></figure><p>这样每次创建新文章的时候，文件名字都会带上时间信息，并且会自动创建一个相对应的资源文件夹。</p><p>其他配置先不做修改，使用默认的值就行。</p><p>至此，博客的基本配置已经完成，我们可以运行命令在本地预览效果：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">➜ hexo <span class="hljs-keyword">server</span><br><span class="hljs-keyword">INFO</span>  Validating config<br><span class="hljs-keyword">INFO</span>  <span class="hljs-keyword">Start</span> processing<br><span class="hljs-keyword">INFO</span>  Hexo <span class="hljs-keyword">is</span> running at http://localhost:<span class="hljs-number">4000</span> . Press Ctrl+C <span class="hljs-keyword">to</span> stop.<br></code></pre></td></tr></table></figure><p>打开 <a href="http://localhost:4000/">http://localhost:4000</a> 即可预览效果。</p><h2 id="部署到-Github-Pages-上"><a href="#部署到-Github-Pages-上" class="headerlink" title="部署到 Github Pages 上"></a>部署到 Github Pages 上</h2><p>首先在 Github 上创建一个仓库，这里我创建了 <code>https://github.com/3vilive/3vilive.github.io</code>。</p><p><code>hexo-deployer-git</code> 是 <code>Hexo</code> 的一个部署插件，我们安装 <code>hexo-deployer-git</code> 后就可以用 <code>Git</code> 来部署了:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>编辑配置文件 (<code>_config.yml</code>)，添加部署信息：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br>deploy:<br>  type: <span class="hljs-string">&#x27;git&#x27;</span><br>  repo: https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/3vilive/</span><span class="hljs-number">3</span>vilive.github.io.git<br>  branch: gh-pages<br></code></pre></td></tr></table></figure><p>执行部署命令：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo deploy</span><br></code></pre></td></tr></table></figure><p>看到最后输出 <code>INFO  Deploy done: git</code> 的时候，说明部署完成了，这时候可以打开仓库主页，看看文件是否已经在仓库里面。 </p><p>点开 Settings -&gt; Pages 页面，如果展示信息为 <code>Your site is published at https://3vilive.github.io/</code> 代表发布成功：</p><p><img src="/2021/07/05/build-personal-blog-base-on-hexo-and-github-pages/github-pages.png"></p><p>说明已经发布成功了，打开 <a href="https://3vilive.github.io/">https://3vilive.github.io</a> 验证一下。</p><p><img src="/2021/07/05/build-personal-blog-base-on-hexo-and-github-pages/blog-home.png"></p><h2 id="开始写作和更新"><a href="#开始写作和更新" class="headerlink" title="开始写作和更新"></a>开始写作和更新</h2><p>使用 hexo new 命令创建新的文章，hexo new 的用法：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">hexo <span class="hljs-keyword">new</span> [layout] &lt;<span class="hljs-built_in">title</span>&gt;<br></code></pre></td></tr></table></figure><p>这里我创建了一篇文章《基于 Hexo 和 Github Pages 服务搭建个人博客实践》:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">➜ hexo <span class="hljs-keyword">new</span> post <span class="hljs-string">&quot;build personal blog base on hexo and github pages&quot;</span><br>INFO  Validating config<br>INFO  Created: ~<span class="hljs-regexp">/dev/</span><span class="hljs-number">3</span>vilive-blog<span class="hljs-regexp">/source/</span>_posts/<span class="hljs-number">2021</span>-<span class="hljs-number">07</span>-<span class="hljs-number">05</span>-build-personal-blog-base-on-hexo-and-github-pages.md<br></code></pre></td></tr></table></figure><p>打开对应的 <code>markdown</code> 文件就可以开始写作了，这里是 <code>~/dev/3vilive-blog/source/_posts/2021-07-05-build-personal-blog-base-on-hexo-and-github-pages.md</code>.</p><p>在写作期间，可以通过 <code>hexo server</code> 来预览最终效果。</p><p>写作完毕后，通过 <code>hexo generate</code> 和 <code>hexo deploy</code> 命令，就可以把文章发布啦。</p><h2 id="自定义主题"><a href="#自定义主题" class="headerlink" title="自定义主题"></a>自定义主题</h2><p>默认的主题有点简陋，这里我找了一个主题还不错：</p><p><a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></p><p>直接跟着里面的教程安装，最终效果如下：</p><p><img src="/2021/07/05/build-personal-blog-base-on-hexo-and-github-pages/use-theme-1.png"></p><p><img src="/2021/07/05/build-personal-blog-base-on-hexo-and-github-pages/use-theme-2.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Github Pages</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
